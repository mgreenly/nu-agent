# Plan: Fix Output System Architecture Issues

## Overview

This plan addresses two fundamental architectural issues with the application's output system:
1. **Paper trail chronology** - Events displayed out of chronological order
2. **ConsoleIO state machine bypass** - Formatters bypassing proper output channels

Both issues existed before parallel execution work but need to be fixed to ensure correct and reliable output behavior.

## Issue 1: Paper Trail Chronological Order

### Problem Statement

The application displays a "paper trail" at the end of each exchange that shows events out of chronological order. This makes it impossible to understand the actual sequence of events.

### Example of Current Broken Behavior

```
> provide me a list of the first line of each file in the docs/ folder

[Real-time debug output shows:]
[Message Out] Created message
[Message In] Created redacted message
[Tool Call Request] file_tree
[Tool Use Response] file_tree
[Message In] Created redacted message
[Tool Call Request] file_read (1/22)
...
[Tool Use Response] file_read (22/22)
[Message In] Created message

[Paper trail shows:]
[Spell Check Request]    ← WRONG! This happened BEFORE Message Out
[Spell Check Result]     ← WRONG! This happened BEFORE Message Out
[Tool Call Request] file_tree
[Tool Use Response] file_tree
...
```

**Actual chronological order should be:**
1. User input received
2. **Spell Check Request/Result** ← Happens first
3. Message Out (sent to LLM)
4. Message In (LLM response with tool calls)
5. Tool execution
6. Repeat steps 3-5 until final response

**Current paper trail shows:**
1. User input
2. Tool calls and responses
3. **Spell Check** ← Shown last but happened first!

## Root Cause Analysis

### Architecture Overview

The application has two output systems:

1. **Real-time debug output** - Shows events as they happen using `application.output_line` with `:debug` type
2. **Paper trail** - Shows conversation history by replaying messages from the formatter

### Why This Happens

The paper trail is generated by the `Formatter` class which displays messages in the order they appear in the conversation history. However:

1. **Spell check happens synchronously** before the first API call in `ChatLoopOrchestrator`
2. **Spell check output is deferred** - It's printed to the paper trail at the END of the exchange
3. **Tool execution is printed immediately** as it happens

This creates a time-travel paradox where:
- Spell check (happens at time T=0) is shown at the end
- Tool execution (happens at time T=10+) is shown in the middle
- The paper trail becomes a non-chronological mess

### Code Locations

**Spell check invocation:**
```ruby
# lib/nu/agent/chat_loop_orchestrator.rb (lines ~60-70)
def create_user_message(user_input)
  # Spell check happens HERE (T=0)
  corrected_input = spellcheck_input(user_input) if @spell_checker

  # Exchange created
  exchange_id = @history.create_exchange(conversation_id: @conversation_id)

  # Message saved
  @history.add_message(...)

  # Return to continue processing
end
```

**Spell check display:**
```ruby
# lib/nu/agent/formatters/formatter.rb
# The spell check request/result is displayed in display_new_messages
# which is called AFTER all tool execution completes
```

## The Fundamental Flaw

**Events are displayed in database insertion order, not chronological execution order.**

The `display_new_messages` method displays all messages that were added to the database since the last display, but:
- Spell check messages are inserted EARLY (before API call)
- But displayed LATE (after tool execution)
- This violates the principle that a paper trail should reflect actual chronology

## The Fix

### Principle

**Every event must be displayed to the paper trail at the moment it occurs, in the order it occurs.**

### Solution Options

#### Option 1: Display Spell Check Immediately (RECOMMENDED)

**Change:** Display spell check request/result immediately when it happens, not deferred to end.

```ruby
# lib/nu/agent/chat_loop_orchestrator.rb
def create_user_message(user_input)
  exchange_id = @history.create_exchange(conversation_id: @conversation_id)

  if @spell_checker
    # Display spell check immediately in paper trail
    @formatter.display_spell_check_request(user_input)
    corrected_input = spellcheck_input(user_input)
    @formatter.display_spell_check_result(corrected_input)
  else
    corrected_input = user_input
  end

  # Continue with message creation...
end
```

**Pros:**
- Simple fix
- Maintains chronological order
- Events appear when they happen

**Cons:**
- None

#### Option 2: Timestamp-Based Display (OVER-ENGINEERED)

Add timestamps to all messages and display in timestamp order.

**Pros:**
- Theoretically more robust

**Cons:**
- Complex implementation
- Unnecessary - we already know the order of events
- Events should be displayed when they happen, not sorted later

### Recommended Approach

**Option 1: Display Immediately**

1. Move spell check display to happen synchronously when spell check executes
2. Remove spell check from deferred `display_new_messages`
3. Ensure paper trail shows events in execution order

## Implementation Plan

### Phase 1: Audit Current Display Flow

**Objective:** Document everywhere that displays to the paper trail and verify chronology.

**Tasks:**
1. Map all `formatter.display_*` calls in `ChatLoopOrchestrator`
2. Map all `formatter.display_*` calls in `ToolCallOrchestrator`
3. Create chronological event diagram showing:
   - When each event occurs
   - When each event is displayed
   - Any mismatches between occurrence and display

**Deliverable:** Event flow diagram in this document

### Phase 2: Fix Spell Check Display

**Objective:** Display spell check immediately when it executes.

**Tasks:**
1. Add `display_spell_check_request` method to Formatter
2. Add `display_spell_check_result` method to Formatter
3. Call these methods in `create_user_message` when spell check executes
4. Remove spell check from `display_new_messages` batch display
5. Verify chronological order in manual testing

**Test Plan:**
- Run application with spell check enabled
- Verify paper trail shows: User Input → Spell Check → LLM Messages → Tools
- Run application with spell check disabled
- Verify paper trail shows: User Input → LLM Messages → Tools

### Phase 3: Audit All Other Events

**Objective:** Ensure no other events have chronology issues.

**Tasks:**
1. Check RAG retrieval display timing
2. Check tool call display timing
3. Check error message display timing
4. Check all message creation display timing

**Acceptance Criteria:**
- All events displayed when they occur
- Paper trail is strictly chronological
- No "time travel" where later events appear before earlier events

### Phase 4: Add Chronology Test

**Objective:** Prevent regression.

**Tasks:**
1. Create `spec/nu/agent/paper_trail_chronology_spec.rb`
2. Test that captures paper trail output
3. Verify events appear in correct chronological order
4. Mock timing to ensure we can detect out-of-order events

**Test scenarios:**
- With spell check enabled
- With spell check disabled
- With multiple tool calling rounds
- With errors

## Event Flow Diagram (To Be Created in Phase 1)

```
Time | Event                           | Currently Displayed | Should Display
-----|--------------------------------|---------------------|---------------
T=0  | User input received            | ✓ Immediately       | ✓ Immediately
T=1  | Spell check request            | ✗ At end           | ✓ Immediately
T=2  | Spell check result             | ✗ At end           | ✓ Immediately
T=3  | Message out to LLM             | ✓ Immediately       | ✓ Immediately
T=4  | Message in from LLM            | ✓ Immediately       | ✓ Immediately
T=5  | Tool call request              | ✓ Immediately       | ✓ Immediately
T=6  | Tool execution                 | ✓ Immediately       | ✓ Immediately
T=7  | Tool result                    | ✓ Immediately       | ✓ Immediately
T=8  | Message out (with tool results)| ✓ Immediately       | ✓ Immediately
T=9  | Final message in               | ✓ Immediately       | ✓ Immediately
T=10 | Assistant response             | ✓ Immediately       | ✓ Immediately
```

---

## Issue 2: ConsoleIO State Machine Bypass

### Problem Statement

The formatters (`ToolCallFormatter`, `ToolResultFormatter`) call `@console.puts()` directly instead of using `application.output_line()`. This bypasses the ConsoleIO state machine and can cause:
1. Output during readline (corrupts user input line)
2. Output during spinner display (visual glitches)
3. Race conditions with the output queue
4. Violations of the state machine contract

### Current Broken Code

```ruby
# lib/nu/agent/formatters/tool_result_formatter.rb:45-46
@console.puts("")
@console.puts("\e[90m[Tool Use Response]#{batch_indicator} #{name}#{timing_indicator}\e[0m")

# lib/nu/agent/formatters/tool_call_formatter.rb:27-28
@console.puts("")
@console.puts("\e[90m[Tool Call Request] #{name}#{count_indicator}\e[0m")
```

### Why This is Wrong

**ConsoleIO State Machine States:**
- `idle` - Ready for output
- `readinguserinput` - Readline active, output should be queued
- `streamingassistant` - Streaming response, output should be coordinated
- `progress` - Progress bar active, output should be queued

**Current behavior:**
- Formatters call `@console.puts()` directly
- This goes straight to stdout regardless of state
- During `readinguserinput`, this corrupts the readline prompt
- During `progress`, this interferes with the progress bar

**Correct behavior:**
- All output should go through `application.output_line(text, type: :debug)`
- `output_line` checks state and either outputs immediately or queues
- ConsoleIO processes queue when state transitions to safe states

### ConsoleIO Architecture

```ruby
# lib/nu/agent/console_io.rb
class ConsoleIO
  def puts(text)
    # Direct output - ONLY use when state is known to be safe
    # Should NOT be called from formatters
  end

  def queue_output(text)
    # Queues output for later display
    # Used when state is not safe for immediate output
  end

  def process_queued_output
    # Displays queued output when state becomes safe
    # Called during state transitions
  end
end

# lib/nu/agent/application.rb
def output_line(text, type: :normal)
  # Smart output that respects state machine
  # Calls console.puts if state is safe
  # Calls console.queue_output if state is unsafe
  # This is what formatters SHOULD use
end
```

### Root Cause

The formatters were written before the state machine was fully implemented, or the state machine requirements weren't communicated to formatter code. The formatters have direct references to `@console` and use it directly.

### The Fix

**Option 1: Remove @console from Formatters (RECOMMENDED)**

Pass output through `application.output_line()` instead of `@console.puts()`.

```ruby
# Current (wrong):
class ToolResultFormatter
  def initialize(console:, application:)
    @console = console    # ← Remove this
    @application = application
  end

  def display_header(...)
    @console.puts("")     # ← Wrong
    @console.puts("...")  # ← Wrong
  end
end

# Fixed (right):
class ToolResultFormatter
  def initialize(application:)
    @application = application
  end

  def display_header(...)
    @application.output_line("", type: :debug)
    @application.output_line("[Tool Use Response]...", type: :debug)
  end
end
```

**Pros:**
- Respects state machine
- No direct console access
- Consistent with other parts of codebase
- Thread-safe (application.output_line handles locking)

**Cons:**
- Need to update all formatter initialization calls
- Need to update all tests
- Breaking change to formatter interface

**Option 2: Add State-Aware Wrapper (COMPROMISE)**

Keep `@console` but add a wrapper that checks state.

```ruby
class ToolResultFormatter
  def safe_puts(text)
    if @console.state == :readinguserinput || @console.state == :progress
      @console.queue_output(text)
    else
      @console.puts(text)
    end
  end

  def display_header(...)
    safe_puts("")
    safe_puts("...")
  end
end
```

**Pros:**
- Minimal code changes
- No interface breaking changes

**Cons:**
- Duplicates logic that already exists in application.output_line
- Formatters still have console dependency
- Harder to test
- Not thread-safe

### Recommended Approach

**Option 1: Remove @console, use application.output_line()**

This is the architecturally correct solution that aligns with the rest of the codebase.

### Code Locations Requiring Changes

**Files with @console.puts():**
1. `lib/nu/agent/formatters/tool_result_formatter.rb` (12 occurrences)
2. `lib/nu/agent/formatters/tool_call_formatter.rb` (8 occurrences)
3. `lib/nu/agent/formatters/message_formatter.rb` (potentially)
4. `lib/nu/agent/formatters/context_formatter.rb` (potentially)

**Initialization sites:**
```bash
# Find all places that create formatters with console:
grep -r "ToolResultFormatter.new" lib/
grep -r "ToolCallFormatter.new" lib/
```

**Test files:**
```bash
# Find all formatter tests that mock console
grep -r "console:" spec/nu/agent/formatters/
```

## Implementation Plan for Issue 2

### Phase 1: Audit All Formatter Console Usage

**Objective:** Identify all formatters using @console and document usage.

**Tasks:**
1. List all formatter classes
2. For each formatter, document all `@console.puts()` calls
3. For each formatter, document initialization signature
4. Find all sites that create formatter instances
5. Find all tests that mock console

**Deliverable:** Complete list of files requiring changes

### Phase 2: Update Formatters (TDD)

**Objective:** Remove @console dependency, use application.output_line()

**For each formatter:**

1. **RED**: Update formatter tests to not pass console
   ```ruby
   # Before:
   formatter = ToolResultFormatter.new(console: console, application: application)

   # After:
   formatter = ToolResultFormatter.new(application: application)
   ```
   Tests should fail because signature changed.

2. **GREEN**: Update formatter implementation
   ```ruby
   # Before:
   def initialize(console:, application:)
     @console = console
     @application = application
   end

   def display_header(...)
     @console.puts("")
     @console.puts("...")
   end

   # After:
   def initialize(application:)
     @application = application
   end

   def display_header(...)
     @application.output_line("", type: :debug)
     @application.output_line("...", type: :debug)
   end
   ```

3. **GREEN**: Update initialization sites
   ```ruby
   # Before:
   @tool_result_formatter = ToolResultFormatter.new(
     console: @console,
     application: @application
   )

   # After:
   @tool_result_formatter = ToolResultFormatter.new(
     application: @application
   )
   ```

4. **VERIFY**: Run tests, ensure all pass

5. **COMMIT**: One commit per formatter

**Order of formatters to fix:**
1. ToolResultFormatter (most critical for parallel execution)
2. ToolCallFormatter (most critical for parallel execution)
3. MessageFormatter
4. ContextFormatter
5. Any other formatters

### Phase 3: Remove Console Parameter from Formatter Base

**Objective:** Update the base formatter class if it exists.

**Tasks:**
1. Check if there's a base Formatter class
2. If yes, update its initialization to not require console
3. Update any documentation about formatter contracts

### Phase 4: Integration Testing

**Objective:** Verify state machine is respected.

**Test scenarios:**
1. **During readline:**
   - Start typing input
   - Have background worker generate output
   - Verify output is queued, not displayed immediately
   - Complete input
   - Verify queued output displays after input submitted

2. **During progress bar:**
   - Start long operation with progress bar
   - Have formatter output occur
   - Verify output is queued, not displayed over progress bar
   - Complete operation
   - Verify queued output displays after progress bar

3. **During tool execution:**
   - Execute tools with parallel execution
   - Verify all tool output respects state machine
   - Verify no visual corruption

**Acceptance Criteria:**
- No direct @console.puts() calls in any formatter
- All formatter output goes through application.output_line()
- Integration tests pass showing proper state handling
- Manual testing shows no visual corruption

---

## Combined Success Criteria

### Issue 1 (Paper Trail Chronology)
- [ ] Paper trail displays events in strict chronological order
- [ ] No events are displayed "out of time"
- [ ] Reading the paper trail gives accurate understanding of what happened and when
- [ ] All timestamps in paper trail (if shown) match actual execution order
- [ ] Test suite includes chronology verification

### Issue 2 (ConsoleIO Bypass)
- [ ] No formatters call @console.puts() directly
- [ ] All formatter output uses application.output_line()
- [ ] Formatters do not have @console instance variable
- [ ] Output respects ConsoleIO state machine
- [ ] No visual corruption during readline, progress bars, or streaming
- [ ] Integration tests verify state machine compliance

## Notes

Both issues existed from previous development sessions and were not caught because:

**Issue 1 (Chronology):**
1. The real-time debug output was correct (masked the issue)
2. The paper trail is typically not scrutinized for chronology
3. Most events happen in the correct order (only spell check is misplaced)

**Issue 2 (ConsoleIO Bypass):**
1. Formatters were written before state machine was complete
2. No integration tests verify state machine compliance
3. Visual corruption only occurs in specific timing scenarios (background workers, parallel tools)
4. Most development/testing happens without state-sensitive operations

However, both are **fundamental correctness issues**:
- **Issue 1** makes debugging impossible by showing events out of order
- **Issue 2** can cause visual corruption and race conditions

## Priority

**CRITICAL** - Both issues undermine system correctness and reliability.

**Issue 1:** HIGH priority - Correctness issue that makes paper trail unreliable
**Issue 2:** CRITICAL priority - Can cause visual corruption and violates architecture contracts

While the application functions correctly (events execute in the right order, state machine works), the output system has serious architectural flaws that must be fixed.

## Estimated Effort

### Issue 1 (Paper Trail Chronology)
- Phase 1 (Audit): 1-2 hours
- Phase 2 (Fix spell check): 2-3 hours
- Phase 3 (Audit other events): 1-2 hours
- Phase 4 (Add tests): 2-3 hours

**Issue 1 Total: 6-10 hours**

### Issue 2 (ConsoleIO Bypass)
- Phase 1 (Audit formatters): 2-3 hours
- Phase 2 (Update formatters TDD): 8-12 hours (2-3 hours per formatter × 4 formatters)
- Phase 3 (Base formatter): 1-2 hours
- Phase 4 (Integration tests): 4-6 hours

**Issue 2 Total: 15-23 hours**

### Combined Total: 21-33 hours

**Recommended approach:** Fix both issues together in a single focused effort, as they both involve the output system architecture.

## Implementation Strategy

### Approach A: Sequential (SAFER)
1. Fix Issue 1 first (paper trail chronology)
2. Then fix Issue 2 (ConsoleIO bypass)
3. Verify both work together

**Pros:** Lower risk, can validate each fix independently
**Cons:** Takes longer, may have merge conflicts

### Approach B: Parallel (FASTER)
1. Create two branches from current
2. Fix Issue 1 in one branch
3. Fix Issue 2 in another branch
4. Merge both, resolve conflicts, test integration

**Pros:** Faster overall
**Cons:** Higher risk, potential conflicts

### Approach C: Combined (RECOMMENDED)
1. Fix both issues in the same branch
2. Coordinate changes to avoid conflicts
3. Test together as they're both output system issues

**Pros:** Ensures compatibility, single test/review cycle
**Cons:** Larger changeset

**Recommendation:** Approach C (Combined) - Both issues affect the same system and should be fixed together.

## Related Issues

**Blocked by these issues:**
- Any new features that add events to paper trail
- Any new formatters
- Parallel execution observability improvements
- Background worker output improvements

**These issues may affect:**
- Real-time progress indicators
- Background worker verbosity output
- Error message display timing
- RAG retrieval logging

## Breaking Changes

### Issue 1: None
- Internal implementation change only
- No API changes

### Issue 2: Yes
**Formatter initialization signature changes:**
```ruby
# Before:
ToolResultFormatter.new(console: console, application: application)

# After:
ToolResultFormatter.new(application: application)
```

**Impact:**
- Any code that creates formatters must be updated
- All formatter tests must be updated
- If formatters are part of public API, this is a breaking change

**Migration path:**
1. Support both signatures temporarily (deprecated warning)
2. Update all internal uses
3. Remove old signature in next major version

**Or:** Make breaking change immediately (simpler, recommended if no external users)

## Testing Strategy

### Unit Tests
- [ ] Spell check displays before LLM call
- [ ] All events display in chronological order
- [ ] Formatters use application.output_line()
- [ ] Formatters don't have @console dependency

### Integration Tests
- [ ] Complete exchange shows correct chronology
- [ ] Output during readline is queued
- [ ] Output during progress bar is queued
- [ ] Parallel tool execution respects state
- [ ] Background workers respect state

### Manual Testing
- [ ] Run with spell check enabled, verify chronology
- [ ] Run parallel tools, check for visual corruption
- [ ] Start typing while background worker outputs
- [ ] Run with progress bars and concurrent output

## Success Metrics

**Quantitative:**
- [ ] Zero direct @console.puts() calls in formatters
- [ ] 100% of events displayed in chronological order
- [ ] All integration tests passing
- [ ] Zero visual corruption in manual testing

**Qualitative:**
- [ ] Paper trail is trustworthy for debugging
- [ ] No user-visible output glitches
- [ ] Architecture is consistent and maintainable
- [ ] Future formatters have clear contracts

## Last Updated

2025-10-31 - Comprehensive plan created covering both paper trail chronology and ConsoleIO bypass issues discovered during parallel execution testing
